# An Algorand Blackjack implementation with Beaker

## Overview

<!-- What is blackjack -->
Blackjack is the most widely played casino banking card game in the world, where players compete against the bank rather than each other. The goal is to get a hand total closer to 21 than the dealer without going over 21.
At the beginning of a game of Blackjack, players and the dealer are each dealt two cards. Players' cards are normally dealt face up, while the dealer has one face down and one face up.
The bank's advantage in this game comes from several rules that favor it. The most significant of these is that the player must act before the dealer, allowing the player to bust and lose the bet before the dealer plays.

The advantage of being able to bet through interaction with a public smart contract on the blockchain compared to playing in classic online casinos is that the goodness of the game does not require trusting a centralized system. Security is therefore directly linked to security by the blockchain itself.

<!-- We use beaker -->
The [Beaker](https://developer.algorand.org/articles/hello-beaker/) framework was used for development. Beaker given its familiarity with python allows to develop smart contracts in a simpler way than using pure PyTeal: it provides easier interaction with contracts, better feedback when the program fails and class-style contract management

## Design

For the development of the contract it was necessary to face some technical challenges: nobody has to know the deck, an actor could stop interacting, someone has to act as dealer. To handle the issue where an actor stops interacting with the contract, a maximum number of rounds has been set for players to perform their next action. If one player does not make his move before the last round expires then the other player can claim victory by forfeit. Instead, the dealer problem was solved by creating a small server that interacts with the contract. Finally, the deck of cards problem is handled as follows: the deck of cards is represented by a string of bytes in the contract state.
<!-- continue -->

The smart contract contract is designed to be developed as a finite state automaton.

![automaton](https://github.com/Geladen/algorand-games-platform/blob/main/automaton.jpg?raw=true)

The smart contract explained below was created to be connected to a gambling platform, for this reason there are fees to be paid in case of victory.

## Implementation

### The state

* *asset*. The asset used for betting. This is the asset that will be transferred to the winner.
* *player*. The player's address.
* *fee_holder*. The address that will receive the fees.
* *bank*. The bank's address.
* *stake*. The amount of the asset that the player has staked.
* *nonce*. A random number that must be present in the player's request.
* *request*. A string generated by the player that determines what card will be drawn next.
* *cards*. The deck of cards.
* *last_card*. The last card that was drawn.
* *cards_left*. The number of cards left in the deck.
* *player_cards*. The cards that the player has.
* *player_min_total*. The minimum total of the player's cards based on the value of the ace.
* *player_max_total*. The maximum total of the player's cards based on the value of the ace.
* *bank_cards*. The cards that the bank has.
* *bank_min_total*. The minimum total of the bank's cards based on the value of the ace.
* *bank_max_total*. The maximum total of the bank's cards based on the value of the ace.
* *state*. The state of the game. It can be one of the following:
  * *init*. When the smart contract is created
  * *poor*. When the SC's address is initialized without setting the stake
  * *wait*. When the creator set the stake and he is waiting for the bank to join
  * *distribute*. When the first 3 cards (2 to the player, 1 to the bank) are being distributed
  * *distribute act*. ...
  * *player*. When the player can decide between: 'stand' or 'hit'
  * *hit act*. When the bank reveals the card drawn by the player
  * *bank*. ...
  * *stand act*. ...
  * *finish*. When the player or the bank won the game
  * *push*. When the game ends in a draw
* *action_timer*. The round in which the last action was executed.
* *winner*. The winner√° address of the game.
* *fee_amount*. The amount of the asset that the fee holder will receive as a fee at the end of the game.

### Creating a blackjack match

An user can create a blackjack game by providing the asset to stake, the address of the bank, the address of the fee holder.

```py
@create
def create(self, asset: abi.Asset, bank: abi.Account, fee_holder: abi.Account):
    return Seq(
        self.asset.set(asset.asset_id()),
        self.bank.set(bank.address()),
        self.fee_holder.set(fee_holder.address()),
        self.cards.set(Bytes(b"\x00"*52)),
        self.cards_left.set(Int(52)),
        self.nonce.set(Int(0)),
        
        self.state.set(INIT),
    )
```

The create function initializes the deck, the actor adresses and the state.

### Defining the stake of the match

The player, after creating the contract, must call the `define_stake` function to set the amount of assets to bet. While setting this amount, the player must also pay that same amount to the contract. This payment must be made in units of the same token that was declared during creation.

```py
@internal
def define_stake(self, txn: abi.AssetTransferTransaction, fee_amount: abi.Uint64):
    return Seq(
        Assert(
            self.state.get() == POOR,
            Txn.sender() == Global.creator_address(),
            
            txn.get().xfer_asset() == self.asset.get(),
            txn.get().asset_receiver() == Global.current_application_address(),
        ),
        
        self.stake.set(txn.get().asset_amount()),
        self.fee_amount.set(fee_amount.get()),

        self.state.set(WAIT),
    )
```

The function sets the amount of the assets to bet, the fee amount to be paid by the player and the state.

### Bank joining the match

To start the game the bank has to join the contract with the `join_server` function. To do this the bank must send the same amount of assets that was previously defined by the player.

```py
@internal
def join_server(self, txn: abi.AssetTransferTransaction, fee_amount: abi.Uint64):
    return Seq(
        Assert(
            self.state.get() == WAIT,
            
            txn.get().sender() == self.bank.get(),
            txn.get().xfer_asset() == self.asset.get(),
            txn.get().asset_receiver() == Global.current_application_address(),
            txn.get().asset_amount() == self.stake.get(),
        ),

        self.fee_amount.set(fee_amount.get()),

        self.state.set(DISTRIBUTE),
        self.action_timer.set(Global.round()), 
    )
```

The function sets the fee amount to be paid by the bank, the action timer, and the state.

### Routing the opt-in methods

Routes the opt-in methods (define_stake and join_server)
txn: transaction that pays the stake
fee_amount: denominator of what will be paid as fee if the joining player wins

```py
@opt_in
def opt_in(self, txn: abi.AssetTransferTransaction, fee_amount: abi.Uint64):
        return If(self.state.get() == POOR).Then(
                self.define_stake(txn, fee_amount)
            ).ElseIf(self.state.get() == WAIT).Then(
                self.join_server(txn, fee_amount)
            ).Else(
                Err()
            )
```

This function checks the state of the smart contract and based on it calls the correct internal function to do the opt-in.

### Initializing the application account

To initialize the application account the creator of the smart contract has pay the fees of the contract and the minimum balance.

```py
@external
def init(self, txn: abi.PaymentTransaction, asset: abi.Asset):
        return Seq(
            Assert(
                self.state.get() == INIT,
                Txn.sender() == Global.creator_address(),
                txn.get().amount() == Int(1000000),
                asset.asset_id() == self.asset.get(),
            ),
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.asset_receiver: Global.current_application_address(),
                TxnField.xfer_asset: self.asset.get(),
                TxnField.asset_amount: Int(0),
            }),
            InnerTxnBuilder.Submit(),
            
            self.state.set(POOR),
        )
```

The function creates and submits an asset transaction, it also sets the new state.

### The bank wins

This function sets the bank as winner in the state.

```py
@internal(TealType.none)
def win_bank(self):        
        return Seq(
            self.state.set(FINISH),
            self.winner.set(self.bank.get())
        )
```

### The player wins

This function sets the player as winner in the state.

```py
@internal(TealType.none)
def win_player(self):
        return Seq(
            self.state.set(FINISH),
            self.winner.set(Global.creator_address())
        )
```

### The game ends in a draw

The function updates the application state to PUSH.

```py
@internal(TealType.none)
def push(self):
        return Seq(
            self.state.set(PUSH),
        )
```

### Handle an actor leaving the match

To prevent the case in which a player realizes he has lost and stops interacting with the contract, the forfeit function has been implemented which can be called by both players. To use the function, a player must have exceeded the maximum time to perform an action.

```py
@external
def forfeit(self):
        return Seq(
            Assert(Or(
                And(
                    Or(
                        self.state.get() == PLAYER,
                        self.state.get() == BANK,
                    ), 
                    Txn.sender() == self.bank.get(),
                ),
                And(
                    Or(
                        self.state.get() == HIT_ACT,
                        self.state.get() == STAND_ACT,
                    ),
                    Txn.sender() == Global.creator_address(),
                ),
                self.action_timer.get() + TIMEOUT <= Global.round(),
            )),
            self.state.set(FINISH),
            self.winner.set(Txn.sender())
        )
```

The function sets the state and the winner of the match.

### Routing the game delete

The `delete` function, like the opt-in, has the aim of routing the possible methods for closing the contract according to the state it is in. The game can end with the `cancel`, `finish` and `give_funds_back` (in case of push) methods.

```py
@delete
def delete(self, asset: abi.Asset, other: abi.Account, fee_holder: abi.Account):
        return Seq(
            Assert(
                asset.asset_id() == self.asset.get(),
                If(Txn.sender() == Global.creator_address()).Then(other.address() == self.bank.get()).Else(other.address() == Global.creator_address()),
                fee_holder.address() == self.fee_holder.get(),
            ),
            If(self.state.get() == FINISH).Then(
                self.finish()
            ).ElseIf(self.state.get() == WAIT).Then(
                self.cancel()
            ).ElseIf(self.state.get() == PUSH).Then(
                self.give_funds_back()
            ).Else(
                Err()
            )
        )
```

### The bank may not join the game

If the bank does not enter the game, the player can decide to cancel the game and get the bet back.

```py
@internal
def cancel(self):
        return Seq(
            Assert(
                Txn.sender() == Global.creator_address(),
                self.state.get() == WAIT,
            ),
            self.give_funds_caller(Int(0)),
        )
```

The function closes the smart contract and sends the assets to the player.

### Someone wins

The winner of the game can call the `finish` function to collect the winnings.

```py
@internal
def finish(self):
        return Seq(
            Assert(
                self.winner.get() == Txn.sender()
            ),
            
            If(self.winner.get() == self.bank.get()).Then(
                self.give_funds_caller(Int(0))
            ).Else(
                self.give_funds_caller(Int(1))
            )
        )
```

### Getting funds back in case of draw

If the match ended in a draw, and the contract status is set to PUSH, the player can get back the assets staked in the match.

```py
@internal(TealType.none)
def give_funds_back(self):
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: self.asset.get(),
                TxnField.asset_amount: self.stake.get(),
                TxnField.asset_receiver: Global.creator_address(),
            }),
            InnerTxnBuilder.Next(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: self.asset.get(),
                TxnField.asset_close_to: self.bank.get(),
            }),
            InnerTxnBuilder.Next(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.Payment,
                TxnField.close_remainder_to: Global.creator_address(),
            }),
            InnerTxnBuilder.Submit(),
        )
```

The function creates and sends a transaction to close the contract and send the funds back to the player.

### Giving funds to the winner

When the player or the bank wins they must receive the won assets. To call the method it is necessary to provide with a boolean whether the winner has to pay the fees or not.

```py
@internal(TealType.none)
    def give_funds_caller(self, pay_fee):
        return Seq(
            InnerTxnBuilder.Begin(),
            If(pay_fee).Then(Seq(
                InnerTxnBuilder.SetFields({
                    TxnField.type_enum: TxnType.AssetTransfer,
                    TxnField.xfer_asset: self.asset.get(),
                    TxnField.asset_amount: self.stake.get() / self.fee_amount.get(),
                    TxnField.asset_receiver: self.fee_holder.get(),
                }),
                InnerTxnBuilder.Next(),
            )),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: self.asset.get(),
                TxnField.asset_close_to: Txn.sender(),
            }),
            InnerTxnBuilder.Next(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.Payment,
                TxnField.close_remainder_to: Global.creator_address(),
            }),
            InnerTxnBuilder.Submit(),
        )
```

The function creates and sends a transaction to close the contract and send the funds to the winner. If specified, the fees are subtracted from the winning amount.

### Getting a card

In order for the player or the bank to receive a card, it must be removed from the deck. To do this you need to provide the id of the card and which player it was drawn by.

```py
    @internal(TealType.uint64)
    def pop_card(self, pos, pop_id):
        i = ScratchVar(TealType.uint64)
        j = ScratchVar(TealType.uint64)
        return Seq(
            For(Seq(i.store(Int(0)), j.store(Int(0))), j.load() <= pos, i.store(i.load() + Int(1))).Do(Seq(
                If(GetByte(self.cards.get(), i.load()) == Int(0)).Then(
                    j.store(j.load() + Int(1))
                )
            )),
            i.store(i.load() - Int(1)),
            self.cards.set(SetByte(self.cards.get(), i.load(), pop_id)),
            self.cards_left.set(self.cards_left.get() - Int(1)),
            self.last_card.set(i.load()),
            
            i.load(),
        )
```

The function performs the update the state of the smart contract by changing the number of cards left in the deck, the drawn card and which player drew it.

To obtain the value of a card it is necessary to call the `card_value` method, which returns the value of a specific card given its id.

```py
    @internal(TealType.uint64)
    def card_value(self, id):
        return Seq(
            Min(id % Int(13) + Int(1), Int(10))
        )
```

The position of a card is obtained from a signature doing the modulo for the number of cards left in the deck.

```py
    @internal(TealType.uint64)
    def sig_to_card_pos(self, sig: abi.DynamicBytes):
        return Seq(
            Btoi(BytesMod(sig.get(), Extract(Itob(self.cards_left.get()), Int(7), Int(1)))),
        )
```

<!-- give card to bank -->
<!-- give card to player -->
<!-- distribute req -->
<!-- distribute act -->
<!-- hit req -->
<!-- hit act -->
<!-- stand req -->
<!-- stand act -->

## Interazione
